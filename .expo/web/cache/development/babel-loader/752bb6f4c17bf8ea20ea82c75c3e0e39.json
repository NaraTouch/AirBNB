{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"C:\\\\React-Native\\\\AirBNB\\\\AirBNB\\\\node_modules\\\\react-navigation\\\\src\\\\views\\\\StackView\\\\StackViewLayout.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport * as React from 'react';\nimport clamp from 'clamp';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport Card from \"./StackViewCard\";\nimport Header from \"../Header/Header\";\nimport NavigationActions from \"../../NavigationActions\";\nimport StackActions from \"../../routers/StackActions\";\nimport SceneView from \"../SceneView\";\nimport withOrientation from \"../withOrientation\";\nimport { NavigationProvider } from \"../NavigationContext\";\nimport TransitionConfigs from \"./StackViewTransitionConfigs\";\nimport * as ReactNativeFeatures from \"../../utils/ReactNativeFeatures\";\n\nvar emptyFunction = function emptyFunction() {};\n\nvar _Dimensions$get = Dimensions.get('window'),\n    WINDOW_WIDTH = _Dimensions$get.width,\n    WINDOW_HEIGHT = _Dimensions$get.height;\n\nvar IS_IPHONE_X = Platform.OS === 'ios' && !Platform.isPad && !Platform.isTVOS && (WINDOW_HEIGHT === 812 || WINDOW_WIDTH === 812);\nvar EaseInOut = Easing.inOut(Easing.ease);\nvar ANIMATION_DURATION = 500;\nvar POSITION_THRESHOLD = 1 / 2;\nvar RESPOND_THRESHOLD = 20;\nvar GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;\nvar GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nvar animatedSubscribeValue = function animatedSubscribeValue(animatedValue) {\n  if (!animatedValue.__isNative) {\n    return;\n  }\n\n  if (Object.keys(animatedValue._listeners).length === 0) {\n    animatedValue.addListener(emptyFunction);\n  }\n};\n\nvar StackViewLayout = function (_React$Component) {\n  _inherits(StackViewLayout, _React$Component);\n\n  var _super = _createSuper(StackViewLayout);\n\n  function StackViewLayout() {\n    var _this;\n\n    _classCallCheck(this, StackViewLayout);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._gestureStartValue = 0;\n    _this._isResponding = false;\n    _this._immediateIndex = null;\n    _this._panResponder = PanResponder.create({\n      onPanResponderTerminate: function onPanResponderTerminate() {\n        _this._isResponding = false;\n\n        _this._reset(index, 0);\n\n        _this.props.onGestureCanceled && _this.props.onGestureCanceled();\n      },\n      onPanResponderGrant: function onPanResponderGrant() {\n        var _this$props$transitio = _this.props.transitionProps,\n            navigation = _this$props$transitio.navigation,\n            position = _this$props$transitio.position,\n            scene = _this$props$transitio.scene;\n        var index = navigation.state.index;\n\n        if (index !== scene.index) {\n          return false;\n        }\n\n        position.stopAnimation(function (value) {\n          _this._isResponding = true;\n          _this._gestureStartValue = value;\n        });\n        _this.props.onGestureBegin && _this.props.onGestureBegin();\n      },\n      onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(event, gesture) {\n        var _this$props = _this.props,\n            _this$props$transitio2 = _this$props.transitionProps,\n            navigation = _this$props$transitio2.navigation,\n            position = _this$props$transitio2.position,\n            layout = _this$props$transitio2.layout,\n            scene = _this$props$transitio2.scene,\n            scenes = _this$props$transitio2.scenes,\n            mode = _this$props.mode;\n        var index = navigation.state.index;\n        var isVertical = mode === 'modal';\n        var options = scene.descriptor.options;\n        var gestureDirection = options.gestureDirection;\n        var gestureDirectionInverted = typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : I18nManager.isRTL;\n\n        if (index !== scene.index) {\n          return false;\n        }\n\n        var immediateIndex = _this._immediateIndex == null ? index : _this._immediateIndex;\n        var currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];\n        var currentDragPosition = event.nativeEvent[isVertical ? 'pageY' : 'pageX'];\n        var axisLength = isVertical ? layout.height.__getValue() : layout.width.__getValue();\n        var axisHasBeenMeasured = !!axisLength;\n        var screenEdgeDistance = gestureDirectionInverted ? axisLength - (currentDragPosition - currentDragDistance) : currentDragPosition - currentDragDistance;\n        var _options$gestureRespo = options.gestureResponseDistance,\n            userGestureResponseDistance = _options$gestureRespo === void 0 ? {} : _options$gestureRespo;\n        var gestureResponseDistance = isVertical ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n\n        if (screenEdgeDistance > gestureResponseDistance) {\n          return false;\n        }\n\n        var hasDraggedEnough = Math.abs(currentDragDistance) > RESPOND_THRESHOLD;\n        var isOnFirstCard = immediateIndex === 0;\n        var shouldSetResponder = hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;\n        return shouldSetResponder;\n      },\n      onPanResponderMove: function onPanResponderMove(event, gesture) {\n        var _this$props2 = _this.props,\n            _this$props2$transiti = _this$props2.transitionProps,\n            navigation = _this$props2$transiti.navigation,\n            position = _this$props2$transiti.position,\n            layout = _this$props2$transiti.layout,\n            scene = _this$props2$transiti.scene,\n            mode = _this$props2.mode;\n        var index = navigation.state.index;\n        var isVertical = mode === 'modal';\n        var options = scene.descriptor.options;\n        var gestureDirection = options.gestureDirection;\n        var gestureDirectionInverted = typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : I18nManager.isRTL;\n        var startValue = _this._gestureStartValue;\n        var axis = isVertical ? 'dy' : 'dx';\n        var axisDistance = isVertical ? layout.height.__getValue() : layout.width.__getValue();\n        var currentValue = axis === 'dx' && gestureDirectionInverted ? startValue + gesture[axis] / axisDistance : startValue - gesture[axis] / axisDistance;\n        var value = clamp(index - 1, currentValue, index);\n        position.setValue(value);\n      },\n      onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {\n        return false;\n      },\n      onPanResponderRelease: function onPanResponderRelease(event, gesture) {\n        var _this$props3 = _this.props,\n            _this$props3$transiti = _this$props3.transitionProps,\n            navigation = _this$props3$transiti.navigation,\n            position = _this$props3$transiti.position,\n            layout = _this$props3$transiti.layout,\n            scene = _this$props3$transiti.scene,\n            mode = _this$props3.mode;\n        var index = navigation.state.index;\n        var isVertical = mode === 'modal';\n        var options = scene.descriptor.options;\n        var gestureDirection = options.gestureDirection;\n        var gestureDirectionInverted = typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : I18nManager.isRTL;\n\n        if (!_this._isResponding) {\n          return;\n        }\n\n        _this._isResponding = false;\n        var immediateIndex = _this._immediateIndex == null ? index : _this._immediateIndex;\n        var axisDistance = isVertical ? layout.height.__getValue() : layout.width.__getValue();\n        var movementDirection = gestureDirectionInverted ? -1 : 1;\n        var movedDistance = movementDirection * gesture[isVertical ? 'dy' : 'dx'];\n        var gestureVelocity = movementDirection * gesture[isVertical ? 'vy' : 'vx'];\n        var defaultVelocity = axisDistance / ANIMATION_DURATION;\n        var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n        var resetDuration = gestureDirectionInverted ? (axisDistance - movedDistance) / velocity : movedDistance / velocity;\n        var goBackDuration = gestureDirectionInverted ? movedDistance / velocity : (axisDistance - movedDistance) / velocity;\n        position.stopAnimation(function (value) {\n          if (gestureVelocity < -0.5) {\n            _this.props.onGestureCanceled && _this.props.onGestureCanceled();\n\n            _this._reset(immediateIndex, resetDuration);\n\n            return;\n          }\n\n          if (gestureVelocity > 0.5) {\n            _this.props.onGestureFinish && _this.props.onGestureFinish();\n\n            _this._goBack(immediateIndex, goBackDuration);\n\n            return;\n          }\n\n          if (value <= index - POSITION_THRESHOLD) {\n            _this.props.onGestureFinish && _this.props.onGestureFinish();\n\n            _this._goBack(immediateIndex, goBackDuration);\n          } else {\n            _this.props.onGestureCanceled && _this.props.onGestureCanceled();\n\n            _this._reset(immediateIndex, resetDuration);\n          }\n        });\n      }\n    });\n\n    _this._getTransitionConfig = function () {\n      var isModal = _this.props.mode === 'modal';\n      return TransitionConfigs.getTransitionConfig(_this.props.transitionConfig, _this.props.transitionProps, _this.props.prevTransitionProps, isModal);\n    };\n\n    _this._renderCard = function (scene) {\n      var _this$_getTransitionC = _this._getTransitionConfig(),\n          screenInterpolator = _this$_getTransitionC.screenInterpolator;\n\n      var style = screenInterpolator && screenInterpolator(_objectSpread(_objectSpread({}, _this.props.transitionProps), {}, {\n        scene: scene\n      }));\n      var options = scene.descriptor.options;\n      var hasHeader = options.header !== null;\n\n      var headerMode = _this._getHeaderMode();\n\n      var marginTop = 0;\n\n      if (!hasHeader && headerMode === 'float') {\n        var isLandscape = _this.props.isLandscape;\n        var headerHeight;\n\n        if (Platform.OS === 'ios') {\n          if (isLandscape && !Platform.isPad) {\n            headerHeight = 52;\n          } else if (IS_IPHONE_X) {\n            headerHeight = 88;\n          } else {\n            headerHeight = 64;\n          }\n        } else {\n          headerHeight = 56;\n        }\n\n        marginTop = -headerHeight;\n      }\n\n      return React.createElement(Card, _extends({}, _this.props.transitionProps, {\n        key: \"card_\" + scene.key,\n        style: [style, {\n          marginTop: marginTop\n        }, _this.props.cardStyle],\n        scene: scene,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 537,\n          columnNumber: 7\n        }\n      }), _this._renderInnerScene(scene));\n    };\n\n    return _this;\n  }\n\n  _createClass(StackViewLayout, [{\n    key: \"_renderHeader\",\n    value: function _renderHeader(scene, headerMode) {\n      var options = scene.descriptor.options;\n      var header = options.header;\n\n      if (header === null && headerMode === 'screen') {\n        return null;\n      }\n\n      if (React.isValidElement(header)) {\n        return header;\n      }\n\n      var renderHeader = header || function (props) {\n        return React.createElement(Header, _extends({}, props, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 106,\n            columnNumber: 46\n          }\n        }));\n      };\n\n      var _this$_getTransitionC2 = this._getTransitionConfig(),\n          headerLeftInterpolator = _this$_getTransitionC2.headerLeftInterpolator,\n          headerTitleInterpolator = _this$_getTransitionC2.headerTitleInterpolator,\n          headerRightInterpolator = _this$_getTransitionC2.headerRightInterpolator;\n\n      var _this$props4 = this.props,\n          mode = _this$props4.mode,\n          transitionProps = _this$props4.transitionProps,\n          prevTransitionProps = _this$props4.prevTransitionProps,\n          passProps = _objectWithoutProperties(_this$props4, [\"mode\", \"transitionProps\", \"prevTransitionProps\"]);\n\n      return renderHeader(_objectSpread(_objectSpread(_objectSpread({}, passProps), transitionProps), {}, {\n        scene: scene,\n        mode: headerMode,\n        transitionPreset: this._getHeaderTransitionPreset(),\n        leftInterpolator: headerLeftInterpolator,\n        titleInterpolator: headerTitleInterpolator,\n        rightInterpolator: headerRightInterpolator\n      }));\n    }\n  }, {\n    key: \"_animatedSubscribe\",\n    value: function _animatedSubscribe(props) {\n      animatedSubscribeValue(props.transitionProps.layout.width);\n      animatedSubscribeValue(props.transitionProps.layout.height);\n      animatedSubscribeValue(props.transitionProps.position);\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset(resetToIndex, duration) {\n      if (Platform.OS === 'ios' && ReactNativeFeatures.supportsImprovedSpringAnimation()) {\n        Animated.spring(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          stiffness: 5000,\n          damping: 600,\n          mass: 3,\n          useNativeDriver: this.props.transitionProps.position.__isNative\n        }).start();\n      } else {\n        Animated.timing(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: this.props.transitionProps.position.__isNative\n        }).start();\n      }\n    }\n  }, {\n    key: \"_goBack\",\n    value: function _goBack(backFromIndex, duration) {\n      var _this2 = this;\n\n      var _this$props$transitio3 = this.props.transitionProps,\n          navigation = _this$props$transitio3.navigation,\n          position = _this$props$transitio3.position,\n          scenes = _this$props$transitio3.scenes;\n      var toValue = Math.max(backFromIndex - 1, 0);\n      this._immediateIndex = toValue;\n\n      var onCompleteAnimation = function onCompleteAnimation() {\n        _this2._immediateIndex = null;\n        var backFromScene = scenes.find(function (s) {\n          return s.index === toValue + 1;\n        });\n\n        if (!_this2._isResponding && backFromScene) {\n          navigation.dispatch(NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true\n          }));\n          navigation.dispatch(StackActions.completeTransition());\n        }\n      };\n\n      if (Platform.OS === 'ios' && ReactNativeFeatures.supportsImprovedSpringAnimation()) {\n        Animated.spring(position, {\n          toValue: toValue,\n          stiffness: 5000,\n          damping: 600,\n          mass: 3,\n          useNativeDriver: position.__isNative\n        }).start(onCompleteAnimation);\n      } else {\n        Animated.timing(position, {\n          toValue: toValue,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: position.__isNative\n        }).start(onCompleteAnimation);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var floatingHeader = null;\n\n      var headerMode = this._getHeaderMode();\n\n      if (headerMode === 'float') {\n        var _scene = this.props.transitionProps.scene;\n        floatingHeader = React.createElement(NavigationProvider, {\n          value: _scene.descriptor.navigation,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 398,\n            columnNumber: 9\n          }\n        }, this._renderHeader(_scene, headerMode));\n      }\n\n      var _this$props5 = this.props,\n          _this$props5$transiti = _this$props5.transitionProps,\n          navigation = _this$props5$transiti.navigation,\n          position = _this$props5$transiti.position,\n          layout = _this$props5$transiti.layout,\n          scene = _this$props5$transiti.scene,\n          scenes = _this$props5$transiti.scenes,\n          mode = _this$props5.mode;\n      var index = navigation.state.index;\n      var isVertical = mode === 'modal';\n      var options = scene.descriptor.options;\n      var gestureDirection = options.gestureDirection;\n      var gestureDirectionInverted = typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : I18nManager.isRTL;\n      var gesturesEnabled = typeof options.gesturesEnabled === 'boolean' ? options.gesturesEnabled : Platform.OS === 'ios';\n      var responder = !gesturesEnabled ? null : this._panResponder;\n      var handlers = gesturesEnabled ? responder.panHandlers : {};\n      var containerStyle = [styles.container, this._getTransitionConfig().containerStyle];\n      return React.createElement(View, _extends({}, handlers, {\n        style: containerStyle,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 431,\n          columnNumber: 7\n        }\n      }), React.createElement(View, {\n        style: styles.scenes,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 432,\n          columnNumber: 9\n        }\n      }, scenes.map(function (s) {\n        return _this3._renderCard(s);\n      })), floatingHeader);\n    }\n  }, {\n    key: \"_getHeaderMode\",\n    value: function _getHeaderMode() {\n      if (this.props.headerMode) {\n        return this.props.headerMode;\n      }\n\n      if (Platform.OS === 'android' || this.props.mode === 'modal') {\n        return 'screen';\n      }\n\n      return 'float';\n    }\n  }, {\n    key: \"_getHeaderTransitionPreset\",\n    value: function _getHeaderTransitionPreset() {\n      if (Platform.OS === 'android' || this._getHeaderMode() === 'screen') {\n        return 'fade-in-place';\n      }\n\n      if (this.props.headerTransitionPreset) {\n        return this.props.headerTransitionPreset;\n      } else {\n        return 'fade-in-place';\n      }\n    }\n  }, {\n    key: \"_renderInnerScene\",\n    value: function _renderInnerScene(scene) {\n      var _scene$descriptor = scene.descriptor,\n          options = _scene$descriptor.options,\n          navigation = _scene$descriptor.navigation,\n          getComponent = _scene$descriptor.getComponent;\n      var SceneComponent = getComponent();\n      var screenProps = this.props.screenProps;\n\n      var headerMode = this._getHeaderMode();\n\n      if (headerMode === 'screen') {\n        return React.createElement(View, {\n          style: styles.container,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 473,\n            columnNumber: 9\n          }\n        }, React.createElement(View, {\n          style: styles.scenes,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 474,\n            columnNumber: 11\n          }\n        }, React.createElement(SceneView, {\n          screenProps: screenProps,\n          navigation: navigation,\n          component: SceneComponent,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 475,\n            columnNumber: 13\n          }\n        })), this._renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(SceneView, {\n        screenProps: screenProps,\n        navigation: navigation,\n        component: SceneComponent,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 486,\n          columnNumber: 7\n        }\n      });\n    }\n  }]);\n\n  return StackViewLayout;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column-reverse'\n  },\n  scenes: {\n    flex: 1\n  }\n});\nexport default withOrientation(StackViewLayout);","map":{"version":3,"sources":["C:/React-Native/AirBNB/AirBNB/node_modules/react-navigation/src/views/StackView/StackViewLayout.js"],"names":["React","clamp","Card","Header","NavigationActions","StackActions","SceneView","withOrientation","NavigationProvider","TransitionConfigs","ReactNativeFeatures","emptyFunction","Dimensions","get","WINDOW_WIDTH","width","WINDOW_HEIGHT","height","IS_IPHONE_X","Platform","OS","isPad","isTVOS","EaseInOut","Easing","inOut","ease","ANIMATION_DURATION","POSITION_THRESHOLD","RESPOND_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","animatedSubscribeValue","animatedValue","__isNative","Object","keys","_listeners","length","addListener","StackViewLayout","_gestureStartValue","_isResponding","_immediateIndex","_panResponder","PanResponder","create","onPanResponderTerminate","_reset","index","props","onGestureCanceled","onPanResponderGrant","transitionProps","navigation","position","scene","state","stopAnimation","value","onGestureBegin","onMoveShouldSetPanResponder","event","gesture","layout","scenes","mode","isVertical","options","descriptor","gestureDirection","gestureDirectionInverted","I18nManager","isRTL","immediateIndex","currentDragDistance","currentDragPosition","nativeEvent","axisLength","__getValue","axisHasBeenMeasured","screenEdgeDistance","gestureResponseDistance","userGestureResponseDistance","vertical","horizontal","hasDraggedEnough","Math","abs","isOnFirstCard","shouldSetResponder","onPanResponderMove","startValue","axis","axisDistance","currentValue","setValue","onPanResponderTerminationRequest","onPanResponderRelease","movementDirection","movedDistance","gestureVelocity","defaultVelocity","velocity","max","resetDuration","goBackDuration","onGestureFinish","_goBack","_getTransitionConfig","isModal","getTransitionConfig","transitionConfig","prevTransitionProps","_renderCard","screenInterpolator","style","hasHeader","header","headerMode","_getHeaderMode","marginTop","isLandscape","headerHeight","key","cardStyle","_renderInnerScene","isValidElement","renderHeader","headerLeftInterpolator","headerTitleInterpolator","headerRightInterpolator","passProps","transitionPreset","_getHeaderTransitionPreset","leftInterpolator","titleInterpolator","rightInterpolator","resetToIndex","duration","supportsImprovedSpringAnimation","Animated","spring","toValue","stiffness","damping","mass","useNativeDriver","start","timing","easing","backFromIndex","onCompleteAnimation","backFromScene","find","s","dispatch","back","route","immediate","completeTransition","floatingHeader","_renderHeader","gesturesEnabled","responder","handlers","panHandlers","containerStyle","styles","container","map","headerTransitionPreset","getComponent","SceneComponent","screenProps","Component","StyleSheet","flex","flexDirection"],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport clamp from 'clamp';\nimport {\n  Animated,\n  StyleSheet,\n  PanResponder,\n  Platform,\n  View,\n  I18nManager,\n  Easing,\n  Dimensions,\n} from 'react-native';\n\nimport Card from './StackViewCard';\nimport Header from '../Header/Header';\nimport NavigationActions from '../../NavigationActions';\nimport StackActions from '../../routers/StackActions';\nimport SceneView from '../SceneView';\nimport withOrientation from '../withOrientation';\nimport { NavigationProvider } from '../NavigationContext';\n\nimport TransitionConfigs from './StackViewTransitionConfigs';\nimport * as ReactNativeFeatures from '../../utils/ReactNativeFeatures';\n\nconst emptyFunction = () => {};\n\nconst { width: WINDOW_WIDTH, height: WINDOW_HEIGHT } = Dimensions.get('window');\nconst IS_IPHONE_X =\n  Platform.OS === 'ios' &&\n  !Platform.isPad &&\n  !Platform.isTVOS &&\n  (WINDOW_HEIGHT === 812 || WINDOW_WIDTH === 812);\n\nconst EaseInOut = Easing.inOut(Easing.ease);\n\n/**\n * The max duration of the card animation in milliseconds after released gesture.\n * The actual duration should be always less then that because the rest distance\n * is always less then the full distance of the layout.\n */\nconst ANIMATION_DURATION = 500;\n\n/**\n * The gesture distance threshold to trigger the back behavior. For instance,\n * `1/2` means that moving greater than 1/2 of the width of the screen will\n * trigger a back action\n */\nconst POSITION_THRESHOLD = 1 / 2;\n\n/**\n * The threshold (in pixels) to start the gesture action.\n */\nconst RESPOND_THRESHOLD = 20;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst animatedSubscribeValue = animatedValue => {\n  if (!animatedValue.__isNative) {\n    return;\n  }\n  if (Object.keys(animatedValue._listeners).length === 0) {\n    animatedValue.addListener(emptyFunction);\n  }\n};\n\nclass StackViewLayout extends React.Component {\n  /**\n   * Used to identify the starting point of the position when the gesture starts, such that it can\n   * be updated according to its relative position. This means that a card can effectively be\n   * \"caught\"- If a gesture starts while a card is animating, the card does not jump into a\n   * corresponding location for the touch.\n   */\n  _gestureStartValue = 0;\n\n  // tracks if a touch is currently happening\n  _isResponding = false;\n\n  /**\n   * immediateIndex is used to represent the expected index that we will be on after a\n   * transition. To achieve a smooth animation when swiping back, the action to go back\n   * doesn't actually fire until the transition completes. The immediateIndex is used during\n   * the transition so that gestures can be handled correctly. This is a work-around for\n   * cases when the user quickly swipes back several times.\n   */\n  _immediateIndex = null;\n\n  _renderHeader(scene, headerMode) {\n    const { options } = scene.descriptor;\n    const { header } = options;\n\n    if (header === null && headerMode === 'screen') {\n      return null;\n    }\n\n    // check if it's a react element\n    if (React.isValidElement(header)) {\n      return header;\n    }\n\n    // Handle the case where the header option is a function, and provide the default\n    const renderHeader = header || (props => <Header {...props} />);\n\n    const {\n      headerLeftInterpolator,\n      headerTitleInterpolator,\n      headerRightInterpolator,\n    } = this._getTransitionConfig();\n\n    const {\n      mode,\n      transitionProps,\n      prevTransitionProps,\n      ...passProps\n    } = this.props;\n\n    return renderHeader({\n      ...passProps,\n      ...transitionProps,\n      scene,\n      mode: headerMode,\n      transitionPreset: this._getHeaderTransitionPreset(),\n      leftInterpolator: headerLeftInterpolator,\n      titleInterpolator: headerTitleInterpolator,\n      rightInterpolator: headerRightInterpolator,\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _animatedSubscribe(props) {\n    // Hack to make this work with native driven animations. We add a single listener\n    // so the JS value of the following animated values gets updated. We rely on\n    // some Animated private APIs and not doing so would require using a bunch of\n    // value listeners but we'd have to remove them to not leak and I'm not sure\n    // when we'd do that with the current structure we have. `stopAnimation` callback\n    // is also broken with native animated values that have no listeners so if we\n    // want to remove this we have to fix this too.\n    animatedSubscribeValue(props.transitionProps.layout.width);\n    animatedSubscribeValue(props.transitionProps.layout.height);\n    animatedSubscribeValue(props.transitionProps.position);\n  }\n\n  _reset(resetToIndex, duration) {\n    if (\n      Platform.OS === 'ios' &&\n      ReactNativeFeatures.supportsImprovedSpringAnimation()\n    ) {\n      Animated.spring(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        stiffness: 5000,\n        damping: 600,\n        mass: 3,\n        useNativeDriver: this.props.transitionProps.position.__isNative,\n      }).start();\n    } else {\n      Animated.timing(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: this.props.transitionProps.position.__isNative,\n      }).start();\n    }\n  }\n\n  _goBack(backFromIndex, duration) {\n    const { navigation, position, scenes } = this.props.transitionProps;\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this._immediateIndex = toValue;\n\n    const onCompleteAnimation = () => {\n      this._immediateIndex = null;\n      const backFromScene = scenes.find(s => s.index === toValue + 1);\n      if (!this._isResponding && backFromScene) {\n        navigation.dispatch(\n          NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true,\n          })\n        );\n        navigation.dispatch(StackActions.completeTransition());\n      }\n    };\n\n    if (\n      Platform.OS === 'ios' &&\n      ReactNativeFeatures.supportsImprovedSpringAnimation()\n    ) {\n      Animated.spring(position, {\n        toValue,\n        stiffness: 5000,\n        damping: 600,\n        mass: 3,\n        useNativeDriver: position.__isNative,\n      }).start(onCompleteAnimation);\n    } else {\n      Animated.timing(position, {\n        toValue,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: position.__isNative,\n      }).start(onCompleteAnimation);\n    }\n  }\n\n  _panResponder = PanResponder.create({\n    onPanResponderTerminate: () => {\n      this._isResponding = false;\n      this._reset(index, 0);\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n    },\n    onPanResponderGrant: () => {\n      const {\n        transitionProps: { navigation, position, scene },\n      } = this.props;\n      const { index } = navigation.state;\n\n      if (index !== scene.index) {\n        return false;\n      }\n\n      position.stopAnimation((value: number) => {\n        this._isResponding = true;\n        this._gestureStartValue = value;\n      });\n      this.props.onGestureBegin && this.props.onGestureBegin();\n    },\n    onMoveShouldSetPanResponder: (event, gesture) => {\n      const {\n        transitionProps: { navigation, position, layout, scene, scenes },\n        mode,\n      } = this.props;\n      const { index } = navigation.state;\n      const isVertical = mode === 'modal';\n      const { options } = scene.descriptor;\n      const gestureDirection = options.gestureDirection;\n\n      const gestureDirectionInverted =\n        typeof gestureDirection === 'string'\n          ? gestureDirection === 'inverted'\n          : I18nManager.isRTL;\n\n      if (index !== scene.index) {\n        return false;\n      }\n\n      const immediateIndex =\n        this._immediateIndex == null ? index : this._immediateIndex;\n      const currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];\n      const currentDragPosition =\n        event.nativeEvent[isVertical ? 'pageY' : 'pageX'];\n      const axisLength = isVertical\n        ? layout.height.__getValue()\n        : layout.width.__getValue();\n      const axisHasBeenMeasured = !!axisLength;\n\n      // Measure the distance from the touch to the edge of the screen\n      const screenEdgeDistance = gestureDirectionInverted\n        ? axisLength - (currentDragPosition - currentDragDistance)\n        : currentDragPosition - currentDragDistance;\n      // Compare to the gesture distance relavant to card or modal\n\n      const {\n        gestureResponseDistance: userGestureResponseDistance = {},\n      } = options;\n      const gestureResponseDistance = isVertical\n        ? userGestureResponseDistance.vertical ||\n          GESTURE_RESPONSE_DISTANCE_VERTICAL\n        : userGestureResponseDistance.horizontal ||\n          GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n      // GESTURE_RESPONSE_DISTANCE is about 25 or 30. Or 135 for modals\n      if (screenEdgeDistance > gestureResponseDistance) {\n        // Reject touches that started in the middle of the screen\n        return false;\n      }\n\n      const hasDraggedEnough =\n        Math.abs(currentDragDistance) > RESPOND_THRESHOLD;\n\n      const isOnFirstCard = immediateIndex === 0;\n      const shouldSetResponder =\n        hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;\n      return shouldSetResponder;\n    },\n    onPanResponderMove: (event, gesture) => {\n      const {\n        transitionProps: { navigation, position, layout, scene },\n        mode,\n      } = this.props;\n      const { index } = navigation.state;\n      const isVertical = mode === 'modal';\n      const { options } = scene.descriptor;\n      const gestureDirection = options.gestureDirection;\n\n      const gestureDirectionInverted =\n        typeof gestureDirection === 'string'\n          ? gestureDirection === 'inverted'\n          : I18nManager.isRTL;\n\n      // Handle the moving touches for our granted responder\n      const startValue = this._gestureStartValue;\n      const axis = isVertical ? 'dy' : 'dx';\n      const axisDistance = isVertical\n        ? layout.height.__getValue()\n        : layout.width.__getValue();\n      const currentValue =\n        axis === 'dx' && gestureDirectionInverted\n          ? startValue + gesture[axis] / axisDistance\n          : startValue - gesture[axis] / axisDistance;\n      const value = clamp(index - 1, currentValue, index);\n      position.setValue(value);\n    },\n    onPanResponderTerminationRequest: () =>\n      // Returning false will prevent other views from becoming responder while\n      // the navigation view is the responder (mid-gesture)\n      false,\n    onPanResponderRelease: (event, gesture) => {\n      const {\n        transitionProps: { navigation, position, layout, scene },\n        mode,\n      } = this.props;\n      const { index } = navigation.state;\n      const isVertical = mode === 'modal';\n      const { options } = scene.descriptor;\n      const gestureDirection = options.gestureDirection;\n\n      const gestureDirectionInverted =\n        typeof gestureDirection === 'string'\n          ? gestureDirection === 'inverted'\n          : I18nManager.isRTL;\n\n      if (!this._isResponding) {\n        return;\n      }\n      this._isResponding = false;\n\n      const immediateIndex =\n        this._immediateIndex == null ? index : this._immediateIndex;\n\n      // Calculate animate duration according to gesture speed and moved distance\n      const axisDistance = isVertical\n        ? layout.height.__getValue()\n        : layout.width.__getValue();\n      const movementDirection = gestureDirectionInverted ? -1 : 1;\n      const movedDistance =\n        movementDirection * gesture[isVertical ? 'dy' : 'dx'];\n      const gestureVelocity =\n        movementDirection * gesture[isVertical ? 'vy' : 'vx'];\n      const defaultVelocity = axisDistance / ANIMATION_DURATION;\n      const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      const resetDuration = gestureDirectionInverted\n        ? (axisDistance - movedDistance) / velocity\n        : movedDistance / velocity;\n      const goBackDuration = gestureDirectionInverted\n        ? movedDistance / velocity\n        : (axisDistance - movedDistance) / velocity;\n\n      // To asyncronously get the current animated value, we need to run stopAnimation:\n      position.stopAnimation(value => {\n        // If the speed of the gesture release is significant, use that as the indication\n        // of intent\n        if (gestureVelocity < -0.5) {\n          this.props.onGestureCanceled && this.props.onGestureCanceled();\n          this._reset(immediateIndex, resetDuration);\n          return;\n        }\n        if (gestureVelocity > 0.5) {\n          this.props.onGestureFinish && this.props.onGestureFinish();\n          this._goBack(immediateIndex, goBackDuration);\n          return;\n        }\n\n        // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n        // and the back will happen.\n        if (value <= index - POSITION_THRESHOLD) {\n          this.props.onGestureFinish && this.props.onGestureFinish();\n          this._goBack(immediateIndex, goBackDuration);\n        } else {\n          this.props.onGestureCanceled && this.props.onGestureCanceled();\n          this._reset(immediateIndex, resetDuration);\n        }\n      });\n    },\n  });\n\n  render() {\n    let floatingHeader = null;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'float') {\n      const { scene } = this.props.transitionProps;\n      floatingHeader = (\n        <NavigationProvider value={scene.descriptor.navigation}>\n          {this._renderHeader(scene, headerMode)}\n        </NavigationProvider>\n      );\n    }\n    const {\n      transitionProps: { navigation, position, layout, scene, scenes },\n      mode,\n    } = this.props;\n    const { index } = navigation.state;\n    const isVertical = mode === 'modal';\n    const { options } = scene.descriptor;\n    const gestureDirection = options.gestureDirection;\n\n    const gestureDirectionInverted =\n      typeof gestureDirection === 'string'\n        ? gestureDirection === 'inverted'\n        : I18nManager.isRTL;\n\n    const gesturesEnabled =\n      typeof options.gesturesEnabled === 'boolean'\n        ? options.gesturesEnabled\n        : Platform.OS === 'ios';\n\n    const responder = !gesturesEnabled ? null : this._panResponder;\n\n    const handlers = gesturesEnabled ? responder.panHandlers : {};\n    const containerStyle = [\n      styles.container,\n      this._getTransitionConfig().containerStyle,\n    ];\n\n    return (\n      <View {...handlers} style={containerStyle}>\n        <View style={styles.scenes}>\n          {scenes.map(s => this._renderCard(s))}\n        </View>\n        {floatingHeader}\n      </View>\n    );\n  }\n\n  _getHeaderMode() {\n    if (this.props.headerMode) {\n      return this.props.headerMode;\n    }\n    if (Platform.OS === 'android' || this.props.mode === 'modal') {\n      return 'screen';\n    }\n    return 'float';\n  }\n\n  _getHeaderTransitionPreset() {\n    // On Android or with header mode screen, we always just use in-place,\n    // we ignore the option entirely (at least until we have other presets)\n    if (Platform.OS === 'android' || this._getHeaderMode() === 'screen') {\n      return 'fade-in-place';\n    }\n\n    // TODO: validations: 'fade-in-place' or 'uikit' are valid\n    if (this.props.headerTransitionPreset) {\n      return this.props.headerTransitionPreset;\n    } else {\n      return 'fade-in-place';\n    }\n  }\n\n  _renderInnerScene(scene) {\n    const { options, navigation, getComponent } = scene.descriptor;\n    const SceneComponent = getComponent();\n\n    const { screenProps } = this.props;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'screen') {\n      return (\n        <View style={styles.container}>\n          <View style={styles.scenes}>\n            <SceneView\n              screenProps={screenProps}\n              navigation={navigation}\n              component={SceneComponent}\n            />\n          </View>\n          {this._renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n    return (\n      <SceneView\n        screenProps={screenProps}\n        navigation={navigation}\n        component={SceneComponent}\n      />\n    );\n  }\n\n  _getTransitionConfig = () => {\n    const isModal = this.props.mode === 'modal';\n\n    return TransitionConfigs.getTransitionConfig(\n      this.props.transitionConfig,\n      this.props.transitionProps,\n      this.props.prevTransitionProps,\n      isModal\n    );\n  };\n\n  _renderCard = scene => {\n    const { screenInterpolator } = this._getTransitionConfig();\n    const style =\n      screenInterpolator &&\n      screenInterpolator({ ...this.props.transitionProps, scene });\n\n    // If this screen has \"header\" set to `null` in it's navigation options, but\n    // it exists in a stack with headerMode float, add a negative margin to\n    // compensate for the hidden header\n    const { options } = scene.descriptor;\n    const hasHeader = options.header !== null;\n    const headerMode = this._getHeaderMode();\n    let marginTop = 0;\n    if (!hasHeader && headerMode === 'float') {\n      const { isLandscape } = this.props;\n      let headerHeight;\n      if (Platform.OS === 'ios') {\n        if (isLandscape && !Platform.isPad) {\n          headerHeight = 52;\n        } else if (IS_IPHONE_X) {\n          headerHeight = 88;\n        } else {\n          headerHeight = 64;\n        }\n      } else {\n        headerHeight = 56;\n        // TODO (Android only): Need to handle translucent status bar.\n      }\n      marginTop = -headerHeight;\n    }\n\n    return (\n      <Card\n        {...this.props.transitionProps}\n        key={`card_${scene.key}`}\n        style={[style, { marginTop }, this.props.cardStyle]}\n        scene={scene}\n      >\n        {this._renderInnerScene(scene)}\n      </Card>\n    );\n  };\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    // Header is physically rendered after scenes so that Header won't be\n    // covered by the shadows of the scenes.\n    // That said, we'd have use `flexDirection: 'column-reverse'` to move\n    // Header above the scenes.\n    flexDirection: 'column-reverse',\n  },\n  scenes: {\n    flex: 1,\n  },\n});\n\nexport default withOrientation(StackViewLayout);\n"]},"metadata":{},"sourceType":"module"}